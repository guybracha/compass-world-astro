---
/**
 * SEO.astro — Drop-in SEO component for Astro (GitHub Pages friendly)
 *
 * Props:
 *  - title: string
 *  - description?: string
 *  - image?: string (absolute or relative; relative will be prefixed with BASE/site)
 *  - imageAlt?: string
 *  - canonical?: string (absolute or relative)
 *  - type?: "website" | "article" (default "website")
 *  - siteName?: string (og:site_name)
 *  - locale?: string (default "en_US")
 *  - robots?: string (e.g., "index,follow")
 *  - twitter?: { card?: "summary" | "summary_large_image"; site?: string; creator?: string }
 *  - publishedTime?: string (ISO) — for article
 *  - modifiedTime?: string (ISO) — for article
 *  - authors?: string[]       — for article
 *  - tags?: string[]          — for article
 */

const {
  title,
  description = "",
  image,
  imageAlt = "",
  canonical,
  type = "website",
  siteName = "Compass World",
  locale = "en_US",
  robots = "index,follow",
  twitter = { card: "summary_large_image" as const },
  publishedTime,
  modifiedTime,
  authors = [],
  tags = [],
} = Astro.props;

// --- helpers: base-aware absolute URLs (works on GitHub Pages subpaths) ---
const BASE = import.meta.env.BASE_URL || "/";
// strip trailing slash for clean joins
const baseRoot = BASE.replace(/\/$/, "");

// Prefer Astro.site when configured, else fallback to base path only
// NOTE: Astro.url is only fully absolute if `site` is set in astro.config.
function absolutize(pathOrUrl: string | undefined | null) {
  if (!pathOrUrl) return undefined;
  if (/^https?:\/\//i.test(pathOrUrl)) return pathOrUrl;
  // try to use Astro.site if defined to make a truly absolute URL
  if (Astro.site) {
    const joined = pathOrUrl.startsWith("/")
      ? pathOrUrl
      : `/${pathOrUrl}`;
    return new URL(joined.replace(/\/{2,}/g, "/"), Astro.site).href;
  }
  // fallback: base-relative (still good for crawlers on GH Pages)
  const joined = pathOrUrl
    ? `${baseRoot}${pathOrUrl.startsWith("/") ? pathOrUrl : `/${pathOrUrl}`}`
    : baseRoot || "/";
  return joined.replace(/\/{2,}/g, "/");
}

const canonicalUrl =
  absolutize(
    canonical ??
      // if site configured, prefer Astro.url; otherwise build from pathname
      (Astro.site ? Astro.url.href : Astro.url.pathname)
  );

const ogImage = absolutize(image);

// --- JSON-LD ---
function websiteJsonLd() {
  return {
    "@context": "https://schema.org",
    "@type": "WebSite",
    "name": siteName,
    "url": canonicalUrl,
  };
}

function articleJsonLd() {
  const data: any = {
    "@context": "https://schema.org",
    "@type": "Article",
    "headline": title,
    "description": description || undefined,
    "image": ogImage ? [ogImage] : undefined,
    "datePublished": publishedTime || undefined,
    "dateModified": modifiedTime || publishedTime || undefined,
    "author": authors.length
      ? authors.map((a) => ({ "@type": "Person", "name": a }))
      : undefined,
    "mainEntityOfPage": canonicalUrl
      ? { "@type": "WebPage", "@id": canonicalUrl }
      : undefined,
  };
  return data;
}

const jsonLd = type === "article" ? articleJsonLd() : websiteJsonLd();
---

<!-- Basic -->
<title>{title}</title>
{description && <meta name="description" content={description} />}

<!-- Canonical -->
{canonicalUrl && <link rel="canonical" href={canonicalUrl} />}

<!-- Robots -->
<meta name="robots" content={robots} />

<!-- Open Graph -->
<meta property="og:type" content={type} />
<meta property="og:title" content={title} />
{description && <meta property="og:description" content={description} />}
{canonicalUrl && <meta property="og:url" content={canonicalUrl} />}
<meta property="og:site_name" content={siteName} />
<meta property="og:locale" content={locale} />
{ogImage && <meta property="og:image" content={ogImage} />}
{ogImage && imageAlt && <meta property="og:image:alt" content={imageAlt} />}

{type === "article" && publishedTime && (
  <meta property="article:published_time" content={publishedTime} />
)}
{type === "article" && modifiedTime && (
  <meta property="article:modified_time" content={modifiedTime} />
)}
{type === "article" && authors.map((a) => (
  <meta property="article:author" content={a} />
))}
{type === "article" && tags.map((t) => (
  <meta property="article:tag" content={t} />
))}

<!-- Twitter -->
<meta name="twitter:card" content={twitter.card || "summary_large_image"} />
{twitter.site && <meta name="twitter:site" content={twitter.site} />}
{twitter.creator && <meta name="twitter:creator" content={twitter.creator} />}
<meta name="twitter:title" content={title} />
{description && <meta name="twitter:description" content={description} />}
{ogImage && <meta name="twitter:image" content={ogImage} />}

<!-- JSON-LD -->
<script type="application/ld+json">
  {JSON.stringify(jsonLd)}
</script>
